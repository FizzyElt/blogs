{"pageProps":{"postData":{"id":"rust-async-programming","contentHtml":"<p>此筆記是對 Rust async book <a href=\"https://rust-lang.github.io/async-book/02_execution/01_chapter.html\">Under the hood: Executing Futures and Tasks</a> 章節作解析。</p>\n<p>閱讀本文必須先備知識</p>\n<ul>\n<li><code>Arc</code> 的作用</li>\n<li>Rust channel 基本概念</li>\n<li>Rust thread 的基本使用</li>\n<li>Future trait 的基本概念</li>\n</ul>\n<h3>前言</h3>\n<p><code>Future</code>，是 Rust 運作非同步程式的核心零件，但是單單只有 <code>Future</code> 整個非同步程式是無法運作的，必須要有個機制去運行跟調度，而這個機制就是 Rust 給予各個到套件跟函式庫去作自由發揮跟設計，每種用法跟效能上都有差異，但 async book 帶著我們做了一個最單純的版本，讓我們透過這個範例去了解實際上 <code>Future</code> 是怎麼被運用，以及 <code>waker</code> 扮演什麼樣的角色。</p>\n<p>建議先照書上全部寫一遍，再來這裡看解說。</p>\n<h4>Executor</h4>\n<p>Executor 是負責對已經實作 Future <code>poll</code> method 的<strong>區塊</strong>或<strong>函式</strong>做 poll，並傳遞一個 <code>waker</code> 給該<strong>區塊</strong>或<strong>函式</strong>，做下次喚醒。\n你會看到範例中會使用 channel 去接收傳來的 task，因為要持續的接收跟執行所以用 while。</p>\n<pre><code class=\"hljs language-scss\">struct Executor {\n  ready_queue: Receiver&#x3C;Arc&#x3C;Task>>,\n}\n\nimpl Executor {\n  fn <span class=\"hljs-built_in\">run</span>(&#x26;self) {\n    while let <span class=\"hljs-built_in\">Ok</span>(task) = self<span class=\"hljs-selector-class\">.ready_queue</span><span class=\"hljs-selector-class\">.recv</span>() {\n\t  let mut future_slot = task<span class=\"hljs-selector-class\">.future</span><span class=\"hljs-selector-class\">.lock</span>()<span class=\"hljs-selector-class\">.unwrap</span>();\n\n\t  if let <span class=\"hljs-built_in\">Some</span>(mut future) = future_slot<span class=\"hljs-selector-class\">.take</span>() {\n        let waker = <span class=\"hljs-built_in\">waker_ref</span>(&#x26;task);\n        let context = &#x26;mut Context::from_waker(&#x26;*waker);\n        \n        if future<span class=\"hljs-selector-class\">.as_mut</span>()<span class=\"hljs-selector-class\">.poll</span>(context)<span class=\"hljs-selector-class\">.is_pending</span>() {\n            *future_slot = <span class=\"hljs-built_in\">Some</span>(future);\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<h4>Spawner</h4>\n<p>主要作為執行 async 區塊作第一次的 poll（讓 Executor 傳遞 <code>waker</code>），不然永遠無法有機會被喚醒。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[derive(Clone)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Spawner</span> {\n  task_sender: SyncSender&#x3C;Arc&#x3C;Task>>,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Spawner</span> {\n  <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">spawn</span>(&#x26;<span class=\"hljs-keyword\">self</span>, future: <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Future</span>&#x3C;Output = ()> + <span class=\"hljs-symbol\">'static</span> + <span class=\"hljs-built_in\">Send</span>) {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">future</span> = future.<span class=\"hljs-title function_ invoke__\">boxed</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">task</span> = Arc::<span class=\"hljs-title function_ invoke__\">new</span>(Task {\n      future: Mutex::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-title function_ invoke__\">Some</span>(future)),\n      task_sender: <span class=\"hljs-keyword\">self</span>.task_sender.<span class=\"hljs-title function_ invoke__\">clone</span>(),\n    });\n\t\t\n    <span class=\"hljs-keyword\">self</span>.task_sender.<span class=\"hljs-title function_ invoke__\">send</span>(task).<span class=\"hljs-title function_ invoke__\">expect</span>(<span class=\"hljs-string\">\"too many tasks queued\"</span>)\n  }\n}\n</code></pre>\n<h4>Task</h4>\n<p>每次執行一個 async 區塊或函式就會產生一個對應的 task 做儲存，當 <code>async</code> 區塊或函式完成時會呼叫  <code>wake</code>，而對應的 task （實作 <code>ArcWake</code> trait）將重新把自己丟到 executor 作  <code>poll</code> ，完成一個非同步操作。</p>\n<pre><code class=\"hljs language-swift\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Task</span> {\n  future: <span class=\"hljs-type\">Mutex</span>&#x3C;<span class=\"hljs-type\">Option</span>&#x3C;<span class=\"hljs-type\">BoxFuture</span>&#x3C;'<span class=\"hljs-keyword\">static</span>, ()>>>,\n  task_sender: <span class=\"hljs-type\">SyncSender</span>&#x3C;<span class=\"hljs-type\">Arc</span>&#x3C;<span class=\"hljs-type\">Task</span>>>,\n}\n\nimpl <span class=\"hljs-type\">ArcWake</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-type\">Task</span> {\n  fn wake_by_ref(arc_self: <span class=\"hljs-operator\">&#x26;</span><span class=\"hljs-type\">Arc</span>&#x3C;<span class=\"hljs-keyword\">Self</span>>) {\n    <span class=\"hljs-keyword\">let</span> cloned <span class=\"hljs-operator\">=</span> arc_self.clone();\n    arc_self\n      .task_sender\n      .send(cloned)\n      .expect(<span class=\"hljs-string\">\"too many task queued\"</span>);\n  }\n}\n</code></pre>\n<p>因為這種機制，所以我們都說 Rust 的非同步是<strong>被動式</strong>的，由 <code>async</code> 區塊或函式本身主動通知 executor 重新 <code>poll</code> 來取得當前進展。</p>\n<h3>流程</h3>\n<p>所以一整個流程從開始到結束是這樣子的</p>\n<ol>\n<li>spawner 將 <code>async</code> 轉成一個 <strong>Task</strong> 丟給 executor 作第一次的 <code>poll</code>。</li>\n<li>由於非同步還沒完成所以回傳 <code>Poll::Pending</code> ，並同時傳遞一個 <code>waker</code> 用於下次完成時喚醒。</li>\n<li>呼叫 <code>wake</code> 並且對應的 <strong>Task</strong> 執行 <code>wake_by_ref</code> ，重新將自己帶到 executor 作 <code>poll</code>。</li>\n<li>收到 <code>Poll::Ready(())</code> 這個非同步操作完整結束</li>\n</ol>\n<h3>Waker</h3>\n<p>既然我們知道整個流程後，那其中最關鍵的當然是 <code>waker</code> ，所以我們可以單純把 <code>waker</code> 抽出來看他怎麼運作。</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Task</span> {\n  name: <span class=\"hljs-type\">String</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">ArcWake</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Task</span> {\n  <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">wake_by_ref</span>(arc_self: &#x26;Arc&#x3C;<span class=\"hljs-keyword\">Self</span>>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"{} wake up\"</span>, arc_self.name);\n  }\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">task</span> = Arc::<span class=\"hljs-title function_ invoke__\">new</span>(Task {\n    name: <span class=\"hljs-string\">\"task\"</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n  });\n\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">waker</span> = waker_ref::&#x3C;Task>(&#x26;task);\n  \n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\"></span><span class=\"hljs-variable\">cloned_waker</span> = waker.<span class=\"hljs-title function_ invoke__\">clone</span>();\n\n  thread::<span class=\"hljs-title function_ invoke__\">spawn</span>(<span class=\"hljs-keyword\">move</span> || {\n    thread::<span class=\"hljs-title function_ invoke__\">sleep</span>(Duration::<span class=\"hljs-title function_ invoke__\">from_secs</span>(<span class=\"hljs-number\">1</span>));\n    cloned_waker.<span class=\"hljs-title function_ invoke__\">wake</span>();\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">\"done\"</span>)\n  })\n  .<span class=\"hljs-title function_ invoke__\">join</span>()\n  .<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n}\n</code></pre>\n<hr>\n<p>以上就是針對 Rust 非同步的簡易解析，如果想知道更詳細，我推薦去看 <a href=\"https://rust-lang.github.io/rfcs/2592-futures.html\">Rust RFC 2592 futures</a>，裡面完整的說明 Future 的設計思路，並且該 RFC 也在翻譯中，敬請期待。</p>","title":"Rust 非同步機制","description":"對於 Rust 非同步程式的初步解析","tags":["Rust","asynchronous"],"editTime":"2022/08/20"}},"__N_SSG":true}